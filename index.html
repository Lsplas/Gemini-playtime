<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: JS Prototype V5</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 15px; left: 15px; color: #fff; z-index: 10; font-weight: bold; font-size: 1.2rem; pointer-events: none; text-shadow: 0 0 5px #fff; }
        #objective { position: absolute; top: 15px; right: 15px; color: #ffaa00; z-index: 10; font-weight: bold; font-size: 1.2rem; pointer-events: none; text-shadow: 0 0 5px #ffaa00; text-align: right; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; 
            background: #fff; border-radius: 50%; transform: translate(-50%, -50%); 
            z-index: 10; pointer-events: none; mix-blend-mode: difference;
        }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; flex-direction: column; z-index: 20;
        }
        #blocker { background: radial-gradient(circle, rgba(20,20,20,0.95) 0%, rgba(0,0,0,1) 100%); color: white; }
        #gameover { background: rgba(150, 0, 0, 0.9); color: white; display: none; }
        h1 { color: #00ffff; text-shadow: 0 0 15px #00ffff; letter-spacing: 3px; margin-bottom: 5px; }
        #gameover h1 { color: #000; text-shadow: 0 0 20px #ff0000; font-size: 4rem; }
        .controls { color: #aaa; margin-top: 20px; text-align: center; line-height: 1.8; }
        .key { background: #333; padding: 2px 6px; border-radius: 4px; color: #fff; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="blocker" class="overlay">
        <h1>PLAYTIME: PROTO-HUNT</h1>
        <p>Click anywhere to begin (Turns on Audio)</p>
        <div class="controls">
            <span class="key">W A S D</span> Move &nbsp;|&nbsp; <span class="key">Mouse</span> Look &nbsp;|&nbsp; <span class="key">Space</span> Jump<br>
            <span class="key">Shift / C</span> Crouch (STEALTH) &nbsp;|&nbsp; <span class="key">Left Click</span> Fire GrabPack
        </div>
    </div>

    <div id="gameover" class="overlay">
        <h1>YOU WERE CAUGHT</h1>
        <p>Refresh the page to try again.</p>
    </div>
    
    <div id="ui">STATUS: <span id="status" style="color:red">UNARMED</span></div>
    <div id="objective">OBJECTIVE:<br><span id="obj-text">Find the GrabPack</span></div>
    <div id="crosshair"></div>

    <script>
        // --- 0. SYNTHETIC AUDIO SYSTEM ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'scan') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.setValueAtTime(900, now + 0.1);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'door') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(40, now);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 2.0);
                osc.start(now); osc.stop(now + 2.0);
            } else if (type === 'step') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.2);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'jumpscare') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                gainNode.gain.setValueAtTime(0.8, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now); osc.stop(now + 1.0);
            }
        }

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010101);
        scene.fog = new THREE.FogExp2(0x010101, 0.03); 

        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x0a0a0a);
        scene.add(ambientLight);

        const flashLight = new THREE.SpotLight(0xffeedd, 1.5, 50, Math.PI / 5, 0.5, 1);
        flashLight.castShadow = true;
        scene.add(flashLight);
        scene.add(flashLight.target);

        // --- 2. ENVIRONMENT ---
        const objects = []; 
        
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(200, 100, 0x0044ff, 0x111111);
        gridHelper.position.y = 0.01; 
        scene.add(gridHelper);

        const boxGeo = new THREE.BoxGeometry(4, 5, 4);
        const boxMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        for (let i = 0; i < 40; i++) {
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.set((Math.random() - 0.5) * 150, 2.5, (Math.random() - 0.5) * 150);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            objects.push(box);
        }

        // --- 3. THE GATE & HAND SCANNER ---
        const gateGeo = new THREE.BoxGeometry(15, 10, 2);
        const gateMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 });
        const gate = new THREE.Mesh(gateGeo, gateMat);
        gate.position.set(0, 5, -30); 
        scene.add(gate);
        let gateTargetY = 5; 

        const scannerGeo = new THREE.BoxGeometry(1.5, 1.5, 0.5);
        const scannerMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }); 
        const scanner = new THREE.Mesh(scannerGeo, scannerMat);
        scanner.position.set(-8, 3, -29);
        scanner.userData = { isScanner: true, isActivated: false };
        scene.add(scanner);
        objects.push(scanner); 

        // --- 4. THE PROTOTYPE ENEMY ---
        const enemyGrp = new THREE.Group();
        
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000022, roughness: 1 });
        const bodyGeo = new THREE.CylinderGeometry(1.2, 0.8, 9, 16);
        const enemyBody = new THREE.Mesh(bodyGeo, bodyMat);
        enemyBody.position.y = 4.5;
        enemyBody.castShadow = true;
        
        const eyeGeo = new THREE.SphereGeometry(0.25);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.4, 8, 1);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.4, 8, 1);

        enemyGrp.add(enemyBody, leftEye, rightEye);
        enemyGrp.position.set(0, 0, -80); 
        scene.add(enemyGrp);
        
        let isEnemyActive = false;
        let lastStepTime = 0;

        // --- 5. COLLECTABLE GRABPACK ---
        let hasGrabPack = false;
        const gpItem = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x008888 }));
        gpItem.position.set(10, 2.5, -10);
        scene.add(gpItem);

        const pedLight = new THREE.PointLight(0x00ffff, 1, 15);
        pedLight.position.set(10, 3, -10);
        scene.add(pedLight);

        const fpModelGroup = new THREE.Group();
        camera.add(fpModelGroup); 
        const leftCannon = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1, 16).rotateX(Math.PI/2), new THREE.MeshStandardMaterial({ color: 0x0055ff }));
        leftCannon.position.set(-0.6, -0.5, -1.2);
        fpModelGroup.add(leftCannon);
        fpModelGroup.visible = false;

        // --- 6. PLAYER CONTROLS ---
        let normalHeight = 3.0, crouchHeight = 1.2, currentTargetHeight = normalHeight;
        let isCrouching = false, canJump = false, isDead = false;
        
        const velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let moveF = false, moveB = false, moveL = false, moveR = false;
        
        let pitchObj = new THREE.Object3D(); pitchObj.add(camera);
        let yawObj = new THREE.Object3D(); yawObj.position.set(0, normalHeight, 15); yawObj.add(pitchObj);
        scene.add(yawObj);

        const blocker = document.getElementById('blocker');
        document.addEventListener('click', () => { 
            initAudio(); // Turn on Audio Context on first click
            if (blocker.style.display !== 'none' && !isDead) document.body.requestPointerLock(); 
        });
        
        document.addEventListener('pointerlockchange', () => {
            if(!isDead) blocker.style.display = document.pointerLockElement === document.body ? 'none' : 'flex';
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body && !isDead) {
                yawObj.rotation.y -= e.movementX * 0.002;
                pitchObj.rotation.x -= e.movementY * 0.002;
                pitchObj.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObj.rotation.x));
            }
        });

        document.addEventListener('keydown', (e) => {
            if(isDead) return;
            switch (e.code) {
                case 'KeyW': moveF = true; break; case 'KeyA': moveL = true; break;
                case 'KeyS': moveB = true; break; case 'KeyD': moveR = true; break;
                case 'Space': if (canJump && !isCrouching) { velocity.y += 12; canJump = false; } break;
                case 'ShiftLeft': case 'KeyC': isCrouching = true; currentTargetHeight = crouchHeight; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveF = false; break; case 'KeyA': moveL = false; break;
                case 'KeyS': moveB = false; break; case 'KeyD': moveR = false; break;
                case 'ShiftLeft': case 'KeyC': isCrouching = false; currentTargetHeight = normalHeight; break;
            }
        });

        // --- 7. GRABPACK LOGIC ---
        const raycaster = new THREE.Raycaster();
        let grabWire = null;
        const uiStatus = document.getElementById('status'), uiObjective = document.getElementById('obj-text');

        document.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement !== document.body || e.button !== 0 || !hasGrabPack || isDead) return;

            playSound('shoot'); // AUDIO
            leftCannon.position.z += 0.2; setTimeout(() => leftCannon.position.z -= 0.2, 100);

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                
                if (hitObj.userData.isScanner && !hitObj.userData.isActivated) {
                    hitObj.userData.isActivated = true;
                    hitObj.material.color.setHex(0x00ff00); 
                    hitObj.material.emissive.setHex(0x005500);
                    gateTargetY = 15; 
                    isEnemyActive = true; 
                    
                    playSound('scan'); // AUDIO
                    setTimeout(() => playSound('door'), 500); // AUDIO
                    
                    uiObjective.innerText = 'SURVIVE.';
                    uiObjective.style.color = '#ff0000';
                } else if (!hitObj.userData.isScanner) {
                    const pullDir = new THREE.Vector3().subVectors(yawObj.position, hitObj.position).normalize();
                    hitObj.position.addScaledVector(pullDir, 4); 
                    hitObj.position.y = 2.5; 
                }

                if (grabWire) scene.remove(grabWire);
                const startPos = new THREE.Vector3(); leftCannon.getWorldPosition(startPos);
                grabWire = new THREE.Line(new THREE.BufferGeometry().setFromPoints([startPos, hitObj.position]), new THREE.LineBasicMaterial({ color: 0x00aaff, linewidth: 5 }));
                scene.add(grabWire);
                setTimeout(() => { scene.remove(grabWire); grabWire = null; }, 250);
            }
        });

        // --- 8. GAME LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            if (isDead) return; 
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            flashLight.position.copy(yawObj.position);
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(pitchObj.getWorldQuaternion(new THREE.Quaternion()));
            flashLight.target.position.copy(yawObj.position).add(dir);

            if (gate.position.y < gateTargetY) gate.position.y += 2 * delta;

            if (!hasGrabPack) {
                gpItem.rotation.y += 2 * delta;
                if (yawObj.position.distanceTo(gpItem.position) < 3.5) {
                    hasGrabPack = true; scene.remove(gpItem, pedLight); fpModelGroup.visible = true;
                    playSound('scan'); // Play collect sound
                    uiStatus.innerText = 'READY'; uiStatus.style.color = '#00ff00';
                    uiObjective.innerText = 'Scan the Gate Button';
                }
            }

            if (isEnemyActive) {
                const distToPlayer = yawObj.position.distanceTo(enemyGrp.position);
                const aggroRadius = isCrouching ? 20 : 60; 

                // Dynamic Footstep Audio
                if (time - lastStepTime > Math.max(0.3, distToPlayer / 40)) {
                    playSound('step');
                    lastStepTime = time;
                }

                if (distToPlayer < aggroRadius) {
                    const moveDir = new THREE.Vector3().subVectors(yawObj.position, enemyGrp.position).normalize();
                    moveDir.y = 0; 
                    enemyGrp.position.addScaledVector(moveDir, 12 * delta); 
                    enemyGrp.lookAt(yawObj.position);
                }

                if (distToPlayer < 3.5) {
                    isDead = true;
                    playSound('jumpscare'); // AUDIO
                    document.exitPointerLock();
                    document.getElementById('gameover').style.display = 'flex';
                }
            }

            yawObj.position.y += (currentTargetHeight - yawObj.position.y) * 10 * delta; 
            const speed = isCrouching ? 20.0 : 45.0; 

            velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 35.0 * delta;
            direction.z = Number(moveF) - Number(moveB); direction.x = Number(moveR) - Number(moveL); direction.normalize();

            if (moveF || moveB) velocity.z -= direction.z * speed * delta;
            if (moveL || moveR) velocity.x -= direction.x * speed * delta;

            yawObj.translateX(-velocity.x * delta); yawObj.translateZ(velocity.z * delta); yawObj.position.y += velocity.y * delta;
            if (yawObj.position.y < currentTargetHeight) { velocity.y = 0; yawObj.position.y = currentTargetHeight; canJump = true; }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
